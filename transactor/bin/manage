#!env python
# -*- mode: Python; fill-column: 79; comment-column: 50; -*-
from __future__ import print_function

import atexit
import functools
import json
import logging
import os
import re

from botocore.exceptions import ClientError
from botocore.exceptions import ProfileNotFound
import boto3
import click


DEFAULT_CF_STACK_NAME = 'WBTransactor'

DEFAULT_CF_TEMPLATE_PATH = os.path.join(os.getcwd(),
                                        'config',
                                        'wb-cf-ensured.json')

manage_cmd_group = functools.partial(click.group, context_settings={
    'help_option_names': ['-h', '--help']
})


logger = logging.getLogger('boto3')


def option(*args, **kw):
    """Factory function for click.option that makes help text more useful.

    When emitted, the help text will display any default passed to the option.

    :returns: Same object as `click.option`.
    """
    default = kw.get('default')
    if default is not None:
        s_default = str(default)
    else:
        s_default = ''
    help_text = kw.get('help', '')
    if all((s_default, help_text, s_default not in help_text)):
        kw['help'] = help_text + ' Default: ' + s_default
    return click.option(*args, **kw)


log_level_option = functools.partial(
    option,
    '-l',
    '--log-level',
    default='WARNING',
    type=click.Choice(choices=('DEBUG', 'INFO', 'WARNING', 'ERROR')),
    help='Logging level.')


def validate_desired_capacity(ctx, param, value):
    """Validates the auto-scaling desired capacity value."""
    if re.match(r'[12]', value) is None:
        raise ValueError('DesiredCapacity Must be 1 or 2')
    return value


desired_capacity_option = functools.partial(
    option, '--desired-capacity',
    default='1',
    type=str,
    callback=validate_desired_capacity,
    help='The number of EC2 instances desired to be in service.')


template_path_option = functools.partial(
    option,
    '--cf-template-path',
    type=click.Path(exists=True),
    help='Path to CloudFormation template file.')


def command_result_reporter(func):
    """Decorator that prints the result of commands.

    Results are printed dependant on the truthy-ness of `verbose` flag
    supplied to the top-level command.
    """

    @functools.wraps(func)
    def reporter(ctx, *args, **kw):
        result = func(ctx, *args, **kw)
        if result and ctx.verbose:
            print(result)

    return reporter


def make_session(profile_name):
    """Create an AWS boto3 session."""
    try:
        sess = boto3.Session(profile_name=profile_name)
    except ProfileNotFound as pnf:
        logger.error(str(pnf))
        click.get_current_context().abort()
    return sess


class CommandContext:

    wb_dp_license_key_path = '/tmp/wp-dp-license.key'

    def __init__(self, profile, cf_stack_name,
                 aws_username=None,
                 verbose=True,
                 settings_path=None):
        self._aws_username = aws_username or profile
        self.profile = profile
        if not profile:
            click.echo('AWS_PROFILE/AWS_DEFAULT_PROFILE '
                       'environment variabable '
                       'has not been set',
                       color='red')
            raise click.Abort()
        self.cf_stack_name = cf_stack_name
        self.session = make_session(self.profile)
        self.verbose = verbose
        self.params = self.read_settings(settings_path)

    @classmethod
    def read_settings(cls, settings_path):
        with open(settings_path) as fp:
            return json.load(fp)
        
    @property
    def aws_username(self):
        if self._aws_username is None:
            return self.profile
        return self._aws_username

    def client(self, name):
        return self.session.client('cloudformation')

    def resource(self, name):
        return self.session.resource(name)

    @property
    def cf_resource(self):
        return self.resource('cloudformation')

    @property
    def cf_client(self):
        return self.client('cloudformation')

    def read_file(self, path):
        with open(path) as fp:
            return fp.read()

    def fetch_datomic_pro_license_key_text(self):
        s3 = self.session.resource('s3')
        bucket = s3.Bucket('wormbase')
        bucket.download_file('datomic-pro/license.key',
                             self.wb_dp_license_key_path)
        return self.read_file(self.wb_dp_license_key_path).rstrip()


pass_command_context = click.make_pass_decorator(CommandContext)


@manage_cmd_group()
@click.argument('settings_path')
@click.argument('cf_stack_name')
@option('--profile',
        default=os.environ.get(
            'AWS_PROFILE', os.environ.get('AWS_DEFAULT_PROFILE', '')),
        help='AWS profile')
@option('--aws-username',
        default=None,
        help='AWS username. Same as profile if not specified.')
@option('--verbose/--quiet', default=True)
@log_level_option(default='INFO')
@click.pass_context
def manage(ctx,
           settings_path,
           cf_stack_name,
           profile,
           aws_username,
           log_level,
           verbose):
    boto3.set_stream_logger(level=getattr(logging, log_level))
    ctx.obj = CommandContext(profile,
                             cf_stack_name,
                             aws_username=aws_username,
                             verbose=verbose,
                             settings_path=settings_path)
    ctx.profile_name = profile
    ctx.session = make_session(ctx.profile_name)
    ctx.cf_stack_name = cf_stack_name

def _make_tags(ctx):
    return [dict(Key='CreatedBy', Value=ctx.aws_username),
            dict(Key='Name', Value=ctx.cf_stack_name),
            dict(Key='Status', Value='production'),
            dict(Key='Role', Value='datomic-transactor'),
            dict(Key='Description',
                 Value=('Instance for running a datomic transactor '
                        'created through CloudFormation'))]


def _parameter(name, value=None):
    param = {'ParameterKey': name}
    if value:
        param['ParameterValue'] = value
    else:
        param['UsePreviousValue'] = True
    return param


@manage.command()
@click.argument('ddb_table_name')
@click.argument('datomic_version')
@desired_capacity_option()
@template_path_option(default=DEFAULT_CF_TEMPLATE_PATH)
@pass_command_context
@command_result_reporter
def create(ctx,
           ddb_table_name,
           datomic_version,
           desired_capacity,
           cf_template_path):
    """Create a new CloudFormation stack for Datomic tranactor(s).
    """
    wb_dp_license_key_text = ctx.fetch_datomic_pro_license_key_text()
    params = [
        _parameter('DDBTableName', ddb_table_name),
        _parameter('DatomicLicenseKey', wb_dp_license_key_text),
        _parameter('DatomicVersion', datomic_version),
        _parameter('AutoScalingDesiredCapacity', desired_capacity),
    ]
    params.extend(_parameter(k, v)
                  for (k, v) in  ctx.params.items())
    kw = dict(StackName=ctx.cf_stack_name,
              TemplateBody=ctx.read_file(cf_template_path),
              Parameters=params,
              Tags=_make_tags(ctx))
    return ctx.cf_resource.create_stack(**kw)


@manage.command()
@click.argument('ddb_table_name')
@option('--datomic-version',
        default=None,
        type=str,
        help='If not specified, use existing version')
@template_path_option(default=None)
@desired_capacity_option()
@pass_command_context
@command_result_reporter
def update(ctx,
           ddb_table_name,
           datomic_version,
           desired_capacity,
           cf_template_path):
    """Update the CloudFormation configuration of the Datomic transactor(s).
    """
    params = ctx.params
    params.extend([
        _parameter('UserName', ctx.profile_name),
        _parameter('DDBTableName', ddb_table_name),
        _parameter('DatomicLicenseKey'),
        _parameter('DatomicVersion', datomic_version),
        _parameter('AutoScalingDesiredCapacity', desired_capacity),
    ])
    kw = dict(StackName=ctx.cf_stack_name,
              Tags=_make_tags(ctx),
              Parameters=params)
    if cf_template_path is None:
        kw['UsePreviousTemplate'] = True
    else:
        kw['TemplateBody'] = ctx.read_file(cf_template_path)
    return ctx.cf_client.update_stack(**kw)


@manage.command()
@pass_command_context
@command_result_reporter
def delete(ctx):
    """Delete the existing CloudFormation stack for the Datomic transactor(s).
    """
    return ctx.cf_client.delete_stack(StackName=ctx.cf_stack_name)


@manage.command()
@pass_command_context
def status(ctx):
    """Report the status of the current transactor stack."""
    stacks = ctx.cf_resource.stacks.filter(StackName=ctx.cf_stack_name)
    try:
        transactors_stack = next(iter(stacks), None)
    except ClientError:
        print('No transactor stack with name', repr(ctx.cf_stack_name))
    else:
        print(transactors_stack.stack_status)
        print('Event log:')
        for se in transactors_stack.events.all():
            ts = se.timestamp.replace(microsecond=0)
            print(ts.isoformat(' '), se.resource_status)


@manage.command('validate-template')
@template_path_option(default=DEFAULT_CF_TEMPLATE_PATH)
@command_result_reporter
@pass_command_context
def validate_template(ctx, cf_template_path):
    """Validate the CloudFormation JSON template."""
    result = ctx.cf_client.validate_template(
        TemplateBody=ctx.read_file(cf_template_path))
    return result


@atexit.register
def clean_up():
    try:
        os.remove(CommandContext.wb_dp_license_key_path)
    except IOError:
        pass


if __name__ == '__main__':
    manage()
